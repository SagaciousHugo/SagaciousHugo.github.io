<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[php中的session和cookie]]></title>
      <url>http://yoursite.com/2016/05/17/php%E4%B8%AD%E7%9A%84session%E5%92%8Ccookie/</url>
      <content type="html"><![CDATA[<p>最近在项目中使用了thinkphp框架，对php中的session和cookie进行了一些研究。根据客户的需求，在文本编辑页面长时间无操作时，用户的登录状态应依然保持，即session和cookie均会自动延长其生存时间。<br><a id="more"></a> </p>
<hr>
<h1 id="session和cookie的由来"><a href="#session和cookie的由来" class="headerlink" title="session和cookie的由来"></a>session和cookie的由来</h1><h3 id="http协议的无状态性"><a href="#http协议的无状态性" class="headerlink" title="http协议的无状态性"></a>http协议的无状态性</h3><p>http是一个无状态协议，每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。<br>http协议具有的这种特性，如果不加扩展改造，就不能满足web应用的需求。通常web应用都是有状态的，前后请求是需要有关联性，比如前一次请求是用户登录，那后一次请求是查看首页。若用户登录请求成功，那么查看首页应该成功；若用户登录请求失败，那么查看首页应该失败且返回登录页。<br>因此，为了使http协议也能够有状态，引入了session和cookie机制。<br>可做此理解，web应用的有状态性 = http的无状态性 + session、cookie状态机制</p>
<h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p>将上面的问题转化为一个生活中超市购物的例子。<br>比如沃尔玛，每天有数以千计的人去进行购物，而你今天去购物，又或者明天去购物，这两次购物行为之间没有什么关系，可以认为是独立的，而且对于超市而言，并不知道这次是谁在购物，这样的一次购物行为就相当于一次http请求。而如果考虑用户购物积分机制，每次购物都会根据金额为该用户增加积分，这样为了证明是你在购物，所以超市会给你发一个凭证——会员卡。<br>于是在每次购物时，出示会员卡，就把这次购物变成了超市知道是某个会员在购物的购物行为。</p>
<p>对于这张会员卡应该有两层理解的含义：1、对于超市，数据库里有一张表，存着这个卡号以及用户的积分信息 2、对于用户，手里有一张卡，卡内有芯片记录着卡号 </p>
<p>把上述例子中将超市变成服务器，将购物的人变成客户端（这里的客户端即，浏览器），购物行为变成访问请求，就回到了web应用场景。<br>那么，用户手里的那张会员卡和超市数据库中存储卡号和用户积分的那条记录在web应用中又是什么呢？<br>答案就是：<br>session的作用就相当于上面所说超市数据库中存储卡号及用户信息的那条记录,sessionid即卡号。<br>cookie的作用就相当于用户手中记录卡号的会员卡。</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>在php中，默认的session机制，是用磁盘文件实现，每一个session都是服务器tmp目录下的一个文件，<br>如图所示：<img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160601105934.jpg" alt="image"><br>在这个文件中通常保存一些用户相关的信息,在本项目中保存了用户id和登录时间，以及这两个参数进行md5加密以后的值，用于之后判断访问请求是否为登录状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    $auth = array(</span><br><span class="line">        &apos;id&apos; =&gt; $id,</span><br><span class="line">        &apos;login_time&apos; =&gt; time(),</span><br><span class="line">    );</span><br><span class="line">    session(&apos;administrator_auth&apos;, $auth);</span><br><span class="line">    session(&apos;administrator_auth_sign&apos;,md5($auth[&apos;id&apos;].$auth[&apos;login_time&apos;]));</span><br><span class="line">    </span><br><span class="line">当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这次请求里是否已包含了一个session标识，即sessionid,如果已包含一个sessionid，则从服务器上找到对应的session使用，否则就创建一个session并把sessionid返回给浏览器。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### cookie</span><br><span class="line">cookie是储存在用户本地终端（浏览器）上的数据，服务器可以利用cookie包含的信息以判断在http传输中的状态。</span><br><span class="line">服务器创建session后，会将sessionid返回给浏览器，浏览器会将sessionid存在cookie中，当再次请求时，浏览器会在请求中带上cookie中所保存的全部参数。  </span><br><span class="line">例如下面的过程：  </span><br><span class="line">第一次请求进入登录页面，cookie中没有sessionid，返回报文给cookie设置sessionid为s1vu7me3dt718g2fjlmuclk2i4</span><br><span class="line">![image](http://o7bsrhxey.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160601112535.png)</span><br><span class="line">此时服务器tmp目录下增加了文件名为sess_s1vu7me3dt718g2fjlmuclk2i4的文件，说明服务器为第一请求创建了对应的session</span><br><span class="line">![image](http://o7bsrhxey.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160601112734.png)</span><br><span class="line">第二次请求用户登录，可以看到请求报文中cookie中有sessionid=s1vu7me3dt718g2fjlmuclk2i4![image](http://o7bsrhxey.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160601112847.png)</span><br><span class="line"></span><br><span class="line"># 如何保持用户登录状态</span><br><span class="line">通过上面的说明，可以知道保持用户登录状态，即一次有状态的访问需要从cookie中得到sessionid，并且服务器tmp目录下有对应的session文件。即保持用户状态需要两个条件：1、cookie有效 2、session有效</span><br><span class="line">这就引出了两个问题，cookie的生命周期和session的生命周期。</span><br><span class="line">### cookie的生命周期</span><br><span class="line">cookie一般不是永久保存在浏览器，当到了过期时间时，cookie会被删除，过期时间一般有以下2种情况</span><br><span class="line">1、浏览会话结束时</span><br><span class="line">如果不进行设置，cookie默认浏览窗口关闭即失效</span><br><span class="line"></span><br><span class="line">2、服务器返回报文set-cookie时，会设置cookie对应的过期时间，则cookie在该过期时间之前均有效</span><br><span class="line"></span><br><span class="line">### session的生命周期</span><br><span class="line">服务器创建session时，会有session对应的失效时间，超过这个时间，服务器会删除tmp目录下对应的session文件。  </span><br><span class="line">//TODO session回收机制</span><br><span class="line"></span><br><span class="line"># 解决问题</span><br><span class="line">那么对于开头需求，在文本编辑页面长时间无操作时，用户的登录状态应依然保持，就需要在这个页面可以保持cookie和session均有效。  </span><br><span class="line">### 1、在对应页面script中使用setInterval方法每隔5分钟向后台发一次请求</span><br></pre></td></tr></table></figure></p>
<p> setInterval(function (){<br>    $.ajax({<br>        url: “{:U(‘sessionDelay’)}”,<br>        type: “GET”,<br>        async: true,<br>        data: {},<br>        dataType: “json”,<br>        success: function(data){<br>            if(data.status==’success’){<br>                console.log(“the user is editing.”);<br>            }<br>        }<br>    });<br>},5<em>60</em>1000);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 2、每次访问请求都更新cookie的过期时间</span><br></pre></td></tr></table></figure>
<p>function <strong>construct() {<br>        parent::</strong>construct();<br>        define(‘ID’, is_login());<br>        if (!ID) {// 还没登录 跳转到登录页面<br>            $this-&gt;redirect(‘Index/login’);<br>        }<br>        cookie(‘PHPSESSID’, cookie(‘PHPSESSID’), array(‘expire’=&gt;24 * 3600, ‘path’=&gt;”/“));<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 3、后台在判断是否登录时，根据需要延长session有效时间</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>检测用户是否登录</li>
<li>@return integer 0：未登录，大于0：当前登录用户ID<br>*/<br>function is_login(){<br> $auth  = session(‘administrator_auth’);<br> if (empty($auth)) {<pre><code>session(&apos;login_update_time&apos;,time());
return 0;
</code></pre> }<br> else {<pre><code>$config = C(&apos;SESSION_OPTIONS&apos;);
if(time() - session(&apos;login_update_time&apos;) &gt; $config[&apos;expire&apos;] / 2 ){
    session(&apos;login_update_time&apos;,time());
}
return session(&apos;administrator_auth_sign&apos;) == md5($auth[&apos;id&apos;].$auth[&apos;login_time&apos;]) ? $auth[&apos;id&apos;] : 0;
</code></pre> }<br>}<br>```<br>通过以上三点，实现了在编辑页面无限长时间无操作，仍然保持用户登录状态。</li>
</ul>
<p>另，thinkphp框架中并没有对cookie进行有效时间设置，所以如果在代码中不显式的设置，那么cookie过期时间均为浏览会话结束时，这样的话即使session依然存在，本地却没有保存sessionid，就无法达到保持登录状态的需求。<br>在研究这个问题时，看到了一篇文章，如下<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160601133111.jpg" alt="image"><br>这位博主错误理解了session和cookie，因为没有显式设置cookie过期时间导致无法保持登录状态，却理解为session失效，以及thinkphp框架有bug，并改了框架源码= =。<br><a href="http://baijunyao.com/article/50" target="_blank" rel="external">原文链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/05/16/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
