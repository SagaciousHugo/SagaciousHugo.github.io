<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[32. Longest Valid Parentheses]]></title>
      <url>http://yoursite.com/2016/06/17/32-Longest-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    private int[] stack = new int[100000];</span><br><span class="line">    private int top = -1;</span><br><span class="line">    private boolean empty  = true;</span><br><span class="line">    </span><br><span class="line">    private void push(int x)&#123;</span><br><span class="line">        stack[++top] = x;</span><br><span class="line">        if(empty = true) &#123;</span><br><span class="line">            empty = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void pop()&#123;</span><br><span class="line">        top--;</span><br><span class="line">        if(top == -1)&#123;</span><br><span class="line">            empty = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int longestValidParentheses(String s) &#123;</span><br><span class="line">        char[] str = s.toCharArray();</span><br><span class="line">        int length = str.length;</span><br><span class="line">        int max_length = 0;</span><br><span class="line">        int last_locate = -1;</span><br><span class="line">        for(int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            if(str[i] == &apos;(&apos;) &#123;</span><br><span class="line">                push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if(empty) &#123;</span><br><span class="line">                    last_locate = i;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    pop();</span><br><span class="line">                    if(empty) &#123;</span><br><span class="line">                       max_length = max_length &gt; i - last_locate ?  max_length : i - last_locate;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                       max_length = max_length &gt; i - stack[top] ?  max_length : i - stack[top];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题目没做出来，参考了别人答案。<br>最初思路的错误在于：<br>1、以为和20题一样，只考虑是否匹配，但是毕竟是Difficulty: Hard<br>2、关键在于是，如何记录当前合法的括号串长度，<br>对于”()((()”这种串，以下两种<br>  （1）入栈长度+1,出栈+1，右括弧不匹配长度清零<br>  （2）入栈长度不变，出栈长度+2，右括弧不匹配长度清零<br>思路都不能准确判断在读入当前字符时，长度到底应该是多少。<br>3、只考虑到了可以以不匹配的右括号作为分隔，但没想到这个分隔除了长度清零还可以有其他作用<br>4、入栈的只是左括号，根本不知道这个左括号是第几位</p>
<p>正确的思路：<br>1、左括号，则入栈其下标<br>2、右括号，判断<br>  （1）如果不匹配，则记录当前位置，结束本次循环<br>  （2）如果匹配，则出栈，出栈后判断是否栈空：<br>        （2.1）若栈空，说明从该处到上次不匹配的位置的串是合法的括号串，那么当前长度为即为上次不匹配的右括号的后一位到当前    （2.2）若栈不空，说明前面有未匹配的左括号，但是当前的右括号匹配上的是刚刚出栈的左括号，两者之间一定是合法的括号串，那么当前长度就是，出栈的左括号到当前右括号（注意，有一个规律：如果堆栈中有挨着的左括号，那么它们的下标一定是连续的，不过不知道这个规律的话，其实也可以在pop前先得到出栈的下标）<br>        另，我们统计的是包含当前位置的全部合法串长，所以覆盖了全部情况。<br>3、关键点：记录下标</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[20. Valid Parentheses]]></title>
      <url>http://yoursite.com/2016/06/17/20-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    private char[] stack =  new char[100];</span><br><span class="line">    private int top = -1;</span><br><span class="line">    </span><br><span class="line">    private void push(char x)&#123;</span><br><span class="line">        stack[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    private void pop()&#123;</span><br><span class="line">       top--;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        char[] str = s.toCharArray();</span><br><span class="line">        int length = str.length;</span><br><span class="line">        try&#123;</span><br><span class="line">              for(int i = 0; i &lt; length ;i++) &#123;</span><br><span class="line">               switch(str[i])&#123;</span><br><span class="line">                   case &apos;(&apos;:</span><br><span class="line">                       push(str[i]);</span><br><span class="line">                       break;</span><br><span class="line">                   case &apos;[&apos;:</span><br><span class="line">                       push(str[i]);</span><br><span class="line">                       break;</span><br><span class="line">                   case &apos;&#123;&apos;:</span><br><span class="line">                       push(str[i]);</span><br><span class="line">                       break;</span><br><span class="line">                   case &apos;)&apos;:</span><br><span class="line">                       if(stack[top] == &apos;(&apos;) &#123;</span><br><span class="line">                           pop();</span><br><span class="line">                       &#125;</span><br><span class="line">                       else &#123;</span><br><span class="line">                         return false;  </span><br><span class="line">                       &#125;</span><br><span class="line">                       break;</span><br><span class="line">                   case &apos;]&apos;:</span><br><span class="line">                        if(stack[top] == &apos;[&apos;) &#123;</span><br><span class="line">                           pop();</span><br><span class="line">                       &#125;</span><br><span class="line">                       else &#123;</span><br><span class="line">                         return false;  </span><br><span class="line">                       &#125;</span><br><span class="line">                       break;</span><br><span class="line">                   case &apos;&#125;&apos;:</span><br><span class="line">                        if(stack[top] == &apos;&#123;&apos;) &#123;</span><br><span class="line">                           pop();</span><br><span class="line">                       &#125;</span><br><span class="line">                       else &#123;</span><br><span class="line">                         return false;  </span><br><span class="line">                       &#125;</span><br><span class="line">                       break;</span><br><span class="line">                   default:</span><br><span class="line">                        return false;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(top == -1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的栈操作。<br>parenthesis[pə’rɛnθəsɪs]圆括号</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[81. Search in Rotated Sorted Array II]]></title>
      <url>http://yoursite.com/2016/06/15/81-Search-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean search(int[] nums, int target) &#123;</span><br><span class="line">        if(nums == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int length = nums.length;</span><br><span class="line">        for(int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            if(nums[i] == target) &#123;</span><br><span class="line">              return true;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题和33题，都可以改为二分查找，时间复杂度会从O(n)降到O(logn)，之后仔细考虑</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[33. Search in Rotated Sorted Array]]></title>
      <url>http://yoursite.com/2016/06/15/33-Search-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        if(nums == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int length = nums.length;</span><br><span class="line">        for(int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            if(nums[i] == target) &#123;</span><br><span class="line">              return i;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[82. Remove Duplicates from Sorted List II]]></title>
      <url>http://yoursite.com/2016/06/15/82-Remove-Duplicates-from-Sorted-List-II/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if(head == null ||head.next == null)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head.next;</span><br><span class="line">        ListNode result = new ListNode(-1);</span><br><span class="line">        ListNode previous = result;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        while(p != null) &#123;</span><br><span class="line">            if(current.val == p.val)&#123;</span><br><span class="line">                while(p != null &amp;&amp; current.val == p.val) &#123;</span><br><span class="line">                     p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">                previous.next = p;</span><br><span class="line">                current = p;</span><br><span class="line">                if(p != null) &#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(current.val != p.val) &#123;</span><br><span class="line">                current.next = p;</span><br><span class="line">                previous.next = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">                previous = previous.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为要把重复的元素都删掉，所以需要两个指针，一个指向当前节点，一个指向当前节点的前一个节点。<br>但由于有可能前几个元素重复，当前节点和当前节点前一个节点的关系不好处理，考虑增加一个额外的头节点，作为初始状态时当前节点的前一个节点。</p>
<p>最开始没想到加头结点，想通过标记重复时的元素值，来判断当前节点是否重复，逻辑有点混乱，有点把自己绕晕。</p>
<p>之后想到加头结点，并且不考虑当前指针回退的问题，在循环中再套一个循环，只要当前节点和p指向的节点（下1,2,3，……n个节点）重复，就让p继续向后移直到为空格或找到不重复的节点，这样逻辑就清晰了许多。</p>
<p>最开始的混乱主要在于创建结果链表时，增加的节点之后是有可能被删除的，就会出现当前指针回退的问题，就容易逻辑混乱。</p>
<p>另，这个题目有过改动，最初题目限制了最多元素重复两次，现在的题目无此限制，应理解为重复任意次数。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[9. Palindrome Number]]></title>
      <url>http://yoursite.com/2016/06/15/9-Palindrome-Number/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    </span><br><span class="line">   public boolean isPalindrome(int x) &#123;</span><br><span class="line">	        int length = 1;</span><br><span class="line">	        long tmp = 9;</span><br><span class="line">	        if( x == -2147483648) &#123;</span><br><span class="line">	            return false;</span><br><span class="line">	        &#125;</span><br><span class="line">	        if(x &lt; 0) &#123;</span><br><span class="line">	            return false;</span><br><span class="line">	        &#125;</span><br><span class="line">	        while(x &gt; tmp) &#123;</span><br><span class="line">	            length++;</span><br><span class="line">	            tmp = tmp * 10 + 9;</span><br><span class="line">	        &#125;</span><br><span class="line">	        return judge(x,length);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    public boolean judge(int x,int length) &#123;</span><br><span class="line">	        int first = x / pow(10,length - 1); </span><br><span class="line">	        int last = x % 10;</span><br><span class="line">	        if(first != last) &#123;</span><br><span class="line">	            return false;</span><br><span class="line">	        &#125;</span><br><span class="line">	        else if(first == last &amp;&amp; (length == 2 || length == 1)) &#123;</span><br><span class="line">	            return true;</span><br><span class="line">	        &#125;</span><br><span class="line">	        else &#123;</span><br><span class="line">	            int next_x = (x - first * pow(10,length - 1) - last) / 10;</span><br><span class="line">	            return judge(next_x,length - 2);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    public int pow(int base, int length)&#123;</span><br><span class="line">	        int result = 1;</span><br><span class="line">	        if(length == 0) &#123;</span><br><span class="line">	            return result;</span><br><span class="line">	        &#125;</span><br><span class="line">	        for(int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">	            result = result * base;</span><br><span class="line">	        &#125;</span><br><span class="line">	        return result;</span><br><span class="line">	    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断回文数字，考虑使用递归<br>1、每次判断传入数字的首位和末位是否相等<br>2、若不等返回false<br>3、若相等且数字长度为1或2，则返回ture<br>3、若相等且数字长度大于2，将本数字首位和末位去掉，递归调用</p>
<p>这里认为负数都不是回文需要注意，题目只是提示这个问题要注意，但并没有说怎么处理，应该属于一种默认。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[8. String to Integer (atoi)]]></title>
      <url>http://yoursite.com/2016/06/15/8-String-to-Integer-atoi/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int myAtoi(String str) &#123;</span><br><span class="line">	        char[] number = str.toCharArray();</span><br><span class="line">	        int count = number.length;</span><br><span class="line">	        long result = 0;</span><br><span class="line">	        int type = 0;</span><br><span class="line">	        int space = 0;</span><br><span class="line">	        int k = 0;</span><br><span class="line">	        for(int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">	            if(number[i] == &apos;-&apos; &amp;&amp; k == 0) &#123;</span><br><span class="line">	                k++;</span><br><span class="line">	                type = 1;</span><br><span class="line">	                continue;</span><br><span class="line">	            &#125;</span><br><span class="line">	            if(number[i]==&apos;+&apos; &amp;&amp; k == 0) &#123;</span><br><span class="line">	                k++;</span><br><span class="line">	                type = 0;</span><br><span class="line">	                continue;</span><br><span class="line">	            &#125;</span><br><span class="line">	            if(number[i] == &apos; &apos; &amp;&amp; k == 0) &#123;</span><br><span class="line">	                continue;</span><br><span class="line">	            &#125;</span><br><span class="line">	            else if(number[i] == &apos; &apos; &amp;&amp; k != 0) &#123;</span><br><span class="line">	                space = 1;</span><br><span class="line">	                continue;</span><br><span class="line">	            &#125;</span><br><span class="line">	            if(number[i] &gt;= 48 &amp;&amp; number[i] &lt;= 57 &amp;&amp; space == 1) &#123;</span><br><span class="line">	                break;</span><br><span class="line">	            &#125;</span><br><span class="line">	            if((number[i] &lt; 48 || number[i] &gt; 57) &amp;&amp; number[i] != &apos; &apos;)&#123;</span><br><span class="line">	                break;</span><br><span class="line">	            &#125;</span><br><span class="line">	            if(number[i] &gt;= 48 &amp;&amp; number[i] &lt;= 57)&#123;</span><br><span class="line">                    if(type == 1)&#123;</span><br><span class="line">                        result = result * 10 - (number[i] - 48);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                       result = result * 10 + number[i] - 48;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k++;</span><br><span class="line">                    if(k &gt; 11)&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        if(result &gt; 2147483647)&#123;</span><br><span class="line">	            return 2147483647;</span><br><span class="line">	        &#125;</span><br><span class="line">	        if(result &lt; -2147483648)&#123;</span><br><span class="line">	            return -2147483648;</span><br><span class="line">	        &#125;</span><br><span class="line">	        return (int)result;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和第七题类型，都需要注意整型溢出的问题，这里是字符串转为整型。<br>考虑先用一个比整型长度要长的数据类型去保存实际值，这样可以判断此时是否溢出，直接用int型保存值的话溢出不太好判断（如果 int x + int y 结果溢出，不会报错，会直接求模得出错误答案），要想判断就需要把int型转为2进制，看原符号位和结果符号位的关系，会比较麻烦。<br>另外，也是要看所谓的spoiler，不看的话不知道溢出时返回什么值，然而这个也是默认缩起的= =。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[7. Reverse Integer]]></title>
      <url>http://yoursite.com/2016/06/15/7-Reverse-Integer/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int reverse(int x) &#123;</span><br><span class="line">        char[] number = String.valueOf(x).toCharArray();</span><br><span class="line">        int length = number.length;</span><br><span class="line">        char[] tmp = new char[length];</span><br><span class="line">         if(number[0] == &apos;-&apos;)&#123;</span><br><span class="line">               tmp[0] = number[0];</span><br><span class="line">               for(int i = 1; i &lt; length; i++ )&#123;</span><br><span class="line">                     tmp[i] = number[length - i];</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                 for(int i = 0; i &lt; length; i++ )&#123;</span><br><span class="line">                     tmp[i] = number[length - i - 1];</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int result = 0;</span><br><span class="line">        try&#123;</span><br><span class="line">             result = Integer.parseInt(String.valueOf(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻转一个整数，需要注意的<br>1、负数时处理符负号<br>2、翻转后溢出时的处理<br>对于考虑溢出这里有点坑，题目对于溢出的说明是没有直接展开<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160615125058.jpg" alt="image"><br>点击之后<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160615125126.jpg" alt="image"><br>不过也怪自己一开始没注意到click to show spoilers（点击看剧透）</p>
<p>对于整型数，需要注意<br>1、int型是32bit，最小值 -2^31（-2147483648）  最大值 2^31 - 1（2147483647）<br>2、unsigned int 最小值 0 最大值 2^32 - 1 （4294967295）<br>3、对于整型数进行变换时，需要注意溢出问题，特别是字符串转整型数，或者其他长度大于整型的数据类型转为整型</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[6. ZigZag Conversion]]></title>
      <url>http://yoursite.com/2016/06/15/6-ZigZag-Conversion/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String convert(String s, int numRows) &#123;</span><br><span class="line">        char[] str = s.toCharArray();</span><br><span class="line">        int count = s.length();</span><br><span class="line">        char[] tmp = new char[count];</span><br><span class="line">        int k = 0;</span><br><span class="line">        int interval = 0;</span><br><span class="line">        int max_interval = numRows * 2 - 2;</span><br><span class="line">        if(max_interval == 0)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; numRows &amp;&amp; k &lt; count; i++ ) &#123;</span><br><span class="line">            if(i &lt; numRows - 1 &amp;&amp; i &gt; 0)&#123;</span><br><span class="line">                interval = (numRows - i - 1) * 2;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                interval = max_interval;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = i; j &lt; count;)&#123;</span><br><span class="line">                tmp[k] = str[j];</span><br><span class="line">                j+= interval;</span><br><span class="line">                if(interval != max_interval)&#123;</span><br><span class="line">                    interval = max_interval - interval;</span><br><span class="line">                &#125;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return String.valueOf(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题的难点：要理解题目<br>ZigZag[‘zɪɡzæɡ] n. 之字形；Z字形<br>题目意思是，给你一个字符串，给你一个行数，你把这个字符串摆成Z字形，再按行拼成一个新的字符串输出<br>如下图所示：<br><img src="http://o7bsrhxey.bkt.clouddn.com/IMG_0500.JPG" alt="image"></p>
<p>关键算法：找规律，原字符串字符位置和新字符串字符位置映射关系，遍历一遍根据映射关系生成新串<br>最初想法<br>把Z字形的上横线和斜线（题目中的话就是第一个竖线和斜线）当成一个单元，其余均是循环，这样就会有一个固定的映射关系。<br>1、生成一个映射关系数组（把一个单元中第i个元素映射到某行），根据行数生成对应个数的队列<br>2、遍历整个字符串，根据映射关系把元素放入对应的队列<br>3、遍历结束后，将全部队列拼起来生成一个字符串</p>
<p>感觉比较麻烦（麻烦在于映射关系只能得出一个元素的行数，不能得出在新串中的位置，这样就需要使用队列保证先后关系），又仔细分析这个Z型的映射关系发现：<br>映射最大间隔是max_interval = 2 <em> numRows - 2;<br>第1行和第n行，映射间隔是max_interval<br>第2行至第n-1行 映射间隔是  (numRows - n - 1) </em> 2  与 max_interval - (numRows - i - 1) * 2 交替<br>如图所示<br><img src="http://o7bsrhxey.bkt.clouddn.com/IMG_0499.JPG" alt="image"></p>
<p>通过这个关系得出了最终代码，这个代码时间打败了百分之95.26%的其他java代码提交者<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160615124547.jpg" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[83.Remove Duplicates from Sorted List]]></title>
      <url>http://yoursite.com/2016/06/15/83-Remove-Duplicates-from-Sorted-List/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">   public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if(head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head.next;</span><br><span class="line">        ListNode result = head;</span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        while(p != null)&#123;</span><br><span class="line">            if(tmp.val != p.val)&#123;</span><br><span class="line">                tmp.next = p;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">            	tmp.next = null;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目挺简单，但还是出了点问题。<br>在while循环中，一开始写的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> while(p != null)&#123;</span><br><span class="line">	if(tmp.val != p.val)&#123;</span><br><span class="line">		tmp.next = p;</span><br><span class="line">		tmp = tmp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	if(tmp.val == p.val) &#123;</span><br><span class="line">		tmp.next = null;</span><br><span class="line">	&#125;</span><br><span class="line">	p = p.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样写的话，在第一次循环时，先执行第一个if，tmp向后移一个节点，导致tmp与p对应同一个节点，从而第二个if也成立，造成错误。<br>在一次循环中，一定要保证对立条件只能成立一个。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[5.Longest Palindromic Substring]]></title>
      <url>http://yoursite.com/2016/06/12/5-Longest%20Palindromic%20Substring/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">  public String longestPalindrome(String s) &#123;</span><br><span class="line">        int substr_start = 0;</span><br><span class="line">        int substr_end = 0;</span><br><span class="line">        int max_length = 0;</span><br><span class="line">        char[] str = s.toCharArray();</span><br><span class="line">        for(int i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">            for(int j = str.length - 1; j - i + 1 &gt; max_length; j--) &#123;</span><br><span class="line">                if(isPalindrome(str,i,j)) &#123;</span><br><span class="line">                    substr_start = i;</span><br><span class="line">                    substr_end = j;</span><br><span class="line">                    max_length = j - i + 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(s.length() - i &lt; max_length) &#123;</span><br><span class="line">            	break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(substr_start,substr_end +1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isPalindrome(char[] str,int start,int end)&#123;</span><br><span class="line">    	int count = end - start + 1;</span><br><span class="line">        for(int i = 0; i &lt; count ; i++)&#123;</span><br><span class="line">        	if(str[start + i] != str[end - i])&#123;</span><br><span class="line">        		return false;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和第3题类似，这里是查找最长回文字串，同样是一次遍历判断全部字串<br>区别在于：<br>1、以下标i为字串起始位置，下标j为字串终止位置<br>2、每选定一个i，j从length-1（即最末尾）开始递减，一旦有符合回文的立刻停止本次关于j的循环（因为j是从最大值开始递减，第一次成立的回文字串，一定是起始位置为i时的最长回文串）<br>3、在i循环中每次判断，当前回文最长字串长度是否大于剩余串长度，若大于，则立刻停止循环（剩余串即使达到最大长度也没当前回文最长字串长度大，就没有继续遍历的必要）</p>
<p>另，这个代码最后运行时间较长，有待之后总结改进。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[4. Median of Two Sorted Arrays]]></title>
      <url>http://yoursite.com/2016/06/12/4-Median%20of%20Two%20Sorted%20Arrays/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int locate = 0;</span><br><span class="line">        double median = 0;</span><br><span class="line">        int m = 0;</span><br><span class="line">        int n = 0;</span><br><span class="line">        int current_number = 0;</span><br><span class="line">        String type = null;</span><br><span class="line">        int length_1 = nums1 != null ? nums1.length : 0 ;</span><br><span class="line">        int length_2 = nums2 != null ? nums2.length : 0 ;</span><br><span class="line">        </span><br><span class="line">        if((length_1 + length_2) % 2 == 0) &#123;</span><br><span class="line">            type = &quot;oven&quot;;</span><br><span class="line">            locate = (length_1 + length_2) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            type = &quot;odd&quot;; </span><br><span class="line">            locate = (int)((length_1 + length_2) / 2) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(length_1 == 0 &amp;&amp; type.equals(&quot;odd&quot;)) &#123;</span><br><span class="line">            return nums2[locate - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(length_1 == 0 &amp;&amp; type.equals(&quot;oven&quot;)) &#123;</span><br><span class="line">            return (double)(nums2[locate - 1] + nums2[locate]) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(length_2 == 0 &amp;&amp; type.equals(&quot;odd&quot;)) &#123;</span><br><span class="line">            return nums1[locate - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(length_2 == 0 &amp;&amp; type.equals(&quot;oven&quot;)) &#123;</span><br><span class="line">            return (double)(nums1[locate - 1] + nums1[locate]) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">             while(m &lt; length_1 || n &lt; length_2) &#123;</span><br><span class="line">                if(m == length_1) &#123;</span><br><span class="line">                    current_number = nums2[n];</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(n == length_2) &#123;</span><br><span class="line">                    current_number = nums1[m];</span><br><span class="line">                    m++;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if(nums1[m] &lt;= nums2[n]) &#123;</span><br><span class="line">                        current_number = nums1[m];</span><br><span class="line">                        m++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        current_number = nums2[n];</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;</span><br><span class="line">                if(m + n == locate) &#123;</span><br><span class="line">                    median = current_number;</span><br><span class="line">                    if(type.equals(&quot;odd&quot;))&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(m + n == locate + 1)&#123;</span><br><span class="line">                    median = (median + current_number) / 2;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        return median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题目主要问题在于特殊情况的处理：<br>1、一个数组为空<br>2、两个数组长度不同<br>3、两个数组元素个数和为奇数或偶数<br>4、传入的是整型数组，返回值为double型，当元素个数和为偶数时，中位数是中间两个数的平均数，此时应将运算时的结果转为double型，如果不指明转换，直接return int型/2，会先按照int型去计算这个结果，return时把int型转为double，这样就会丢失可能存在的0.5。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[3.Longest Substring Without Repeating Characters]]></title>
      <url>http://yoursite.com/2016/06/12/3-Longest%20Substring%20Without%20Repeating%20Characters/</url>
      <content type="html"><![CDATA[<p>最初的思路是把分割字串和判断字串是否有重复字符分开判断，而且用的是比较暴力的方法，结果一直是超时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int max_length = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.length();i++) &#123;</span><br><span class="line">            for(int j = i + 1; j &lt;= s.length() ;j++) </span><br><span class="line">            if(judgeSubstring(s.substring(i,j)) == -1 &amp;&amp; s.substring(i,j).length() &gt; max_length) &#123;</span><br><span class="line">                max_length = s.substring(i,j).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int judgeSubstring(String substring) &#123;</span><br><span class="line">        int index = -1;</span><br><span class="line">        for(int i = 0; i &lt; substring.length(); i++) &#123;</span><br><span class="line">            index = substring.indexOf(substring.charAt(i),i + 1);</span><br><span class="line">            if(index &gt; -1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后想到使用哈希表来加快判断字串中是否有重复字符，即把每个字符的ascii码作为哈希表的下标，然而仍然超时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int max_length = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.length();) &#123;</span><br><span class="line">            for(int j = i + 1; j &lt;= s.length() ;j++) &#123;</span><br><span class="line">            	int index = judgeSubstring(s.substring(i,j));</span><br><span class="line">	            if( index == -1&amp;&amp; s.substring(i,j).length() &gt; max_length) &#123;</span><br><span class="line">	                max_length = s.substring(i,j).length();</span><br><span class="line">	            &#125;</span><br><span class="line">	            else if(index != -1)&#123;</span><br><span class="line">	                i = i + index ;</span><br><span class="line">	                break;</span><br><span class="line">	            &#125;</span><br><span class="line">	            if(j == s.length()) &#123;</span><br><span class="line">	            	i = j;</span><br><span class="line">	            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int judgeSubstring(String s) &#123;</span><br><span class="line">        int repeat_index = -1;</span><br><span class="line">        int[] hashTable = new int[256];</span><br><span class="line">        int[] locateTable = new int[256];</span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if(hashTable[(int)s.charAt(i)] == 0) &#123;</span><br><span class="line">            	hashTable[(int)s.charAt(i)]++;</span><br><span class="line">            	locateTable[(int)s.charAt(i)] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">            	repeat_index = locateTable[(int)s.charAt(i)] + 1;</span><br><span class="line">            	break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return repeat_index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后想到，其实并不需要分割字串那一步<br>一次遍历即可判断多个子串的算法如下：<br>1、用i标记当前读第几个字符，初始值为0；用locate_start标记当前判断字串起始位置，初始值为0<br>2、从s中读第i个字符，判断该字符是否在当前串中存在（查看哈希表对应位置是否为0）<br>3、若存在，则下一个字串起始位置变成重复字符（是下标已经存入哈希表那个字符，不是当前读到的字符）的后一个字符<br>4、若不存在，则将当前字符的下标存入哈希表对应位置，判断当前串长度是否大于串最大长度，若大于则串最大长度变为当前串长度<br>5、若字符串还未结束，回到第2步，否则结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">  public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int max_length = 0;</span><br><span class="line">        int locate_start = 0;</span><br><span class="line">        int[] hashTable = new int[256];</span><br><span class="line">        int[] locateTable = new int[256];</span><br><span class="line">        for(int i = 0; i &lt; s.length();) &#123;</span><br><span class="line">        	if(hashTable[(int)s.charAt(i)] == 0) &#123;</span><br><span class="line">        		if(max_length &lt; i - locate_start + 1) &#123;</span><br><span class="line">            		max_length = i - locate_start + 1;</span><br><span class="line">            	&#125;</span><br><span class="line">            	hashTable[(int)s.charAt(i)]++;</span><br><span class="line">            	locateTable[(int)s.charAt(i)] = i;</span><br><span class="line">            	i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">            	locate_start = locateTable[(int)s.charAt(i)] + 1;</span><br><span class="line">            	i = locate_start;</span><br><span class="line">            	hashTable = new int[256];</span><br><span class="line">                locateTable = new int[256];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2. Add Two Numbers]]></title>
      <url>http://yoursite.com/2016/06/12/2-Add%20Two%20Numbers/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        int index_sum = 0;</span><br><span class="line">        ListNode p = null;</span><br><span class="line">        ListNode tmp = null;</span><br><span class="line">        ListNode tmp1 = l1;</span><br><span class="line">        ListNode tmp2 = l2;</span><br><span class="line">        int val1,val2;</span><br><span class="line">        while(tmp1 != null || tmp2 != null) &#123;</span><br><span class="line">            val1 = tmp1 != null ? tmp1.val : 0;</span><br><span class="line">            val2 = tmp2 != null ? tmp2.val : 0;</span><br><span class="line">            index_sum = val1 + val2 + carry;</span><br><span class="line">            if(index_sum &gt; 9)&#123;</span><br><span class="line">                index_sum = index_sum - 10;</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125; </span><br><span class="line">            else &#123;</span><br><span class="line">                carry = 0; </span><br><span class="line">            &#125;</span><br><span class="line">            if(p == null) &#123;</span><br><span class="line">                tmp = new ListNode(index_sum);</span><br><span class="line">                p = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">             tmp.next = new ListNode(index_sum);   </span><br><span class="line">             tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp1 != null) &#123;</span><br><span class="line">                tmp1 = tmp1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp2 != null) &#123;</span><br><span class="line">                tmp2 = tmp2.next; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        if(carry == 1) &#123;</span><br><span class="line">            tmp.next = new ListNode(1);  </span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作单链表进行运算，需要注意的是特殊情况的处理：<br>1、两个链表长度不同，一个链表为空<br>3、最后一位进位问题，生成的链表长度会是MAX(l1,l2)+1</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[1. Two Sum]]></title>
      <url>http://yoursite.com/2016/06/12/1-Two%20Sum/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int index_1 = 0;</span><br><span class="line">        int index_2 = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for(int j = i + 1; j &lt; nums.length; j++) </span><br><span class="line">                if(nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    index_1 = i;</span><br><span class="line">                    index_2 = j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;index_1,index_2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找一个数组中两个和为指定值的数的下标，最简单的方法就是直接遍历求和，之后看看是否有更有效的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php session源码分析]]></title>
      <url>http://yoursite.com/2016/06/08/php-session%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>在研究php session回收机制的时候，发现了一种奇怪的现象：假如服务器只有一个人访问（且此时垃圾回收概率设置为1），若此时session已经过期，那么再次访问时他的session仍然存在。看了一些资料，了解到session执行时，有以下几个步骤：<br><a id="more"></a><br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160606142537.jpg" alt="image">  </p>
<h2 id="本着严谨的态度，对php-src-version-7-中session-c进行了一些研究。"><a href="#本着严谨的态度，对php-src-version-7-中session-c进行了一些研究。" class="headerlink" title="本着严谨的态度，对php-src version 7 中session.c进行了一些研究。"></a>本着严谨的态度，对php-src version 7 中session.c进行了一些研究。</h2><h2 id="php源码从哪找？"><a href="#php源码从哪找？" class="headerlink" title="php源码从哪找？"></a>php源码从哪找？</h2><p>1、官网 <a href="http://windows.php.net/download/" target="_blank" rel="external">http://windows.php.net/download/</a><br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160607095502.jpg" alt="image"><br>2、php的github 账号 <a href="https://github.com/php/php-src" target="_blank" rel="external">https://github.com/php/php-src</a></p>
<p>另，官网有linux的包，但暂时linux还不太会用= =，之后再补上linux下看源码的方法。</p>
<h2 id="php源码目录结构"><a href="#php源码目录结构" class="headerlink" title="php源码目录结构"></a>php源码目录结构</h2><p>如图所示（php-src version 7）<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160608135710.jpg" alt="image"><br>具体说明如下：</p>
<ol>
<li>build 和编译有关的目录。</li>
<li>ext 扩展库代码，例如 mysql、zlib、iconv、session（本次研究的session.c就在该目录下） 等扩展库。其中/ext/standard/ 目录下是常用的标准函数集。</li>
<li>main 主目录包含主要的 PHP 宏和定义。</li>
<li>对netware支持，Netware是NOVELL公司推出的网络操作系统。</li>
<li>pear 这个目录就是“PHP 扩展与应用仓库”的目录。包含了PEAR 的核心文件。</li>
<li>sapi 和各种服务器的接口调用，例如apache、IIS等，也包含一般的fastcgi、cgi等。<br>scripts Linux 下的脚本目录。</li>
<li>TSRM Zend 和 PHP 的 “线程安全资源管理器” (TSRM) 目录。</li>
<li>travis持续集成工具</li>
<li>tests 测试脚本目录</li>
<li>win32 和 Windows 下编译 PHP 有关的脚本。</li>
<li>Zend 文件夹核心的引擎，所有的 Zend API 定义与宏等。</li>
</ol>
<p>另：<br>php-src/main/php.h, 位于PHP主目录。这个文件包含了绝大部分 PHP 宏及 API 定义。<br>php-src/Zend/zend.h, 位于Zend 主目录。这个文件包含了绝大部分 Zend 宏及 API 定义。<br>php-src/Zend/zend_API.h, 也位于Zend 主目录，包含了Zend API 的定义</p>
<h2 id="php内核面向对象的类结构"><a href="#php内核面向对象的类结构" class="headerlink" title="php内核面向对象的类结构"></a>php内核面向对象的类结构</h2><p><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160608142212.jpg" alt="image"><br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160608142652.jpg" alt="image"><br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160608142248.jpg" alt="image"></p>
<h2 id="session-c"><a href="#session-c" class="headerlink" title="session.c"></a>session.c</h2><p>查看源码可以发现，在php_session_initialize方法里调用了open、read、gc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">static void php_session_initialize(void) /* &#123;&#123;&#123; */</span><br><span class="line">&#123;</span><br><span class="line">	zend_string *val = NULL;</span><br><span class="line"></span><br><span class="line">	PS(session_status) = php_session_active;</span><br><span class="line"></span><br><span class="line">	if (!PS(mod)) &#123;</span><br><span class="line">		PS(session_status) = php_session_disabled;</span><br><span class="line">		php_error_docref(NULL, E_ERROR, &quot;No storage module chosen - failed to initialize session&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Open session handler first */</span><br><span class="line">	if (PS(mod)-&gt;s_open(&amp;PS(mod_data), PS(save_path), PS(session_name)) == FAILURE</span><br><span class="line">		/* || PS(mod_data) == NULL */ /* FIXME: open must set valid PS(mod_data) with success */</span><br><span class="line">	) &#123;</span><br><span class="line">		php_session_abort();</span><br><span class="line">		php_error_docref(NULL, E_ERROR, &quot;Failed to initialize storage module: %s (path: %s)&quot;, PS(mod)-&gt;s_name, PS(save_path));</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* If there is no ID, use session module to create one */</span><br><span class="line">	if (!PS(id) || !ZSTR_VAL(PS(id))[0]) &#123;</span><br><span class="line">		if (PS(id)) &#123;</span><br><span class="line">			zend_string_release(PS(id));</span><br><span class="line">		&#125;</span><br><span class="line">		PS(id) = PS(mod)-&gt;s_create_sid(&amp;PS(mod_data));</span><br><span class="line">		if (!PS(id)) &#123;</span><br><span class="line">			php_session_abort();</span><br><span class="line">			php_error_docref(NULL, E_ERROR, &quot;Failed to create session ID: %s (path: %s)&quot;, PS(mod)-&gt;s_name, PS(save_path));</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (PS(use_cookies)) &#123;</span><br><span class="line">			PS(send_cookie) = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else if (PS(use_strict_mode) &amp;&amp; PS(mod)-&gt;s_validate_sid &amp;&amp;</span><br><span class="line">		PS(mod)-&gt;s_validate_sid(&amp;PS(mod_data), PS(id)) == FAILURE) &#123;</span><br><span class="line">		if (PS(id)) &#123;</span><br><span class="line">			zend_string_release(PS(id));</span><br><span class="line">		&#125;</span><br><span class="line">		PS(id) = PS(mod)-&gt;s_create_sid(&amp;PS(mod_data));</span><br><span class="line">		if (!PS(id)) &#123;</span><br><span class="line">			PS(id) = php_session_create_id(NULL);</span><br><span class="line">		&#125;</span><br><span class="line">		if (PS(use_cookies)) &#123;</span><br><span class="line">			PS(send_cookie) = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	php_session_reset_id();</span><br><span class="line"></span><br><span class="line">	/* Read data */</span><br><span class="line">	php_session_track_init();</span><br><span class="line">	if (PS(mod)-&gt;s_read(&amp;PS(mod_data), PS(id), &amp;val, PS(gc_maxlifetime)) == FAILURE) &#123;</span><br><span class="line">		php_session_abort();</span><br><span class="line">		/* Some broken save handler implementation returns FAILURE for non-existent session ID */</span><br><span class="line">		/* It&apos;s better to raise error for this, but disabled error for better compatibility */</span><br><span class="line">		php_error_docref(NULL, E_WARNING, &quot;Failed to read session data: %s (path: %s)&quot;, PS(mod)-&gt;s_name, PS(save_path));</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* GC must be done after read */</span><br><span class="line">	php_session_gc();</span><br><span class="line"></span><br><span class="line">	if (PS(session_vars)) &#123;</span><br><span class="line">		zend_string_release(PS(session_vars));</span><br><span class="line">		PS(session_vars) = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	if (val) &#123;</span><br><span class="line">		if (PS(lazy_write)) &#123;</span><br><span class="line">			PS(session_vars) = zend_string_copy(val);</span><br><span class="line">		&#125;</span><br><span class="line">		php_session_decode(val);</span><br><span class="line">		zend_string_release(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在php_session_save_current_state调用了write、close<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void php_session_save_current_state(int write) <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	int ret = FAILURE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (write) &#123;</span><br><span class="line">		IF_SESSION_VARS() &#123;</span><br><span class="line">			<span class="keyword">if</span> (PS(mod_data) || PS(mod_user_implemented)) &#123;</span><br><span class="line">				zend_string *val;</span><br><span class="line"></span><br><span class="line">				val = php_session_encode();</span><br><span class="line">				<span class="keyword">if</span> (val) &#123;</span><br><span class="line">					<span class="keyword">if</span> (PS(lazy_write) &amp;&amp; PS(session_vars)</span><br><span class="line">						&amp;&amp; PS(mod)-&gt;s_update_timestamp</span><br><span class="line">						&amp;&amp; PS(mod)-&gt;s_update_timestamp != php_session_update_timestamp</span><br><span class="line">						&amp;&amp; ZSTR_LEN(val) == ZSTR_LEN(PS(session_vars))</span><br><span class="line">						&amp;&amp; !memcmp(ZSTR_VAL(val), ZSTR_VAL(PS(session_vars)), ZSTR_LEN(val))</span><br><span class="line">					) &#123;</span><br><span class="line">						ret = PS(mod)-&gt;s_update_timestamp(&amp;PS(mod_data), PS(id), val, PS(gc_maxlifetime));</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						ret = PS(mod)-&gt;s_write(&amp;PS(mod_data), PS(id), val, PS(gc_maxlifetime));</span><br><span class="line">					&#125;</span><br><span class="line">					zend_string_release(val);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ret = PS(mod)-&gt;s_write(&amp;PS(mod_data), PS(id), ZSTR_EMPTY_ALLOC(), PS(gc_maxlifetime));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((ret == FAILURE) &amp;&amp; !EG(<span class="keyword">exception</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!PS(mod_user_implemented)) &#123;</span><br><span class="line">					php_error_docref(<span class="keyword">NULL</span>, E_WARNING, <span class="string">"Failed to write session data (%s). Please "</span></span><br><span class="line">									 <span class="string">"verify that the current setting of session.save_path "</span></span><br><span class="line">									 <span class="string">"is correct (%s)"</span>,</span><br><span class="line">									 PS(mod)-&gt;s_name,</span><br><span class="line">									 PS(save_path));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					php_error_docref(<span class="keyword">NULL</span>, E_WARNING, <span class="string">"Failed to write session data using user "</span></span><br><span class="line">									 <span class="string">"defined save handler. (session.save_path: %s)"</span>, PS(save_path));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PS(mod_data) || PS(mod_user_implemented)) &#123;</span><br><span class="line">		PS(mod)-&gt;s_close(&amp;PS(mod_data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面说的，我们可以知道session的回收机制，确实是<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160606142537.jpg" alt="image">  </p>
<p>参考资料<br>1、php-zend引擎分析 <a href="http://rapheal.sinaapp.com/2013/11/14/php_zend_lex/" target="_blank" rel="external">原文链接</a><br>2、php内核探索：一次请求生命周期 <a href="http://www.nowamagic.net/librarys/veda/detail/1287" target="_blank" rel="external">原文链接</a><br>3、php内核面向对象总结 <a href="http://blog.jobbole.com/97790/" target="_blank" rel="external">原文链接</a><br>4、php内核探索之变量（5）- session的基本原理 <a href="http://blog.csdn.net/ohmygirl/article/details/43152683" target="_blank" rel="external">原文链接</a><br>5、深入理解php之源码目录结构 <a href="http://blog.csdn.net/ctowoo/article/details/4626188" target="_blank" rel="external">原文链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php session回收机制]]></title>
      <url>http://yoursite.com/2016/06/06/php-session%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>在上一篇文章中说明了要保持用户的登录状态，必须保证cookie和session均有效，而如果换一种角度，问题就变为如何在规定时间内使用户登录状态失效呢？我们先从下面的问题说起。<br>（注意，本篇基于php默认session机制，php.ini配置：session.save_handler = files，即使用服务器/tmp目录下的文件来保存session）。</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a><a id="more"></a> </h2><blockquote>
<h3 id="如何设置一个严格30分钟过期的Session"><a href="#如何设置一个严格30分钟过期的Session" class="headerlink" title="如何设置一个严格30分钟过期的Session"></a><a href="http://www.laruence.com/2012/01/10/2469.html" target="_blank" rel="external">如何设置一个严格30分钟过期的Session</a></h3></blockquote>
<p>在该文章中，讨论了4种答案，其中前两种错误，后两种正确。</p>
<h5 id="答案1：session设置过期时间-session-gc-maxlifetime"><a href="#答案1：session设置过期时间-session-gc-maxlifetime" class="headerlink" title="答案1：session设置过期时间(session.gc_maxlifetime)"></a>答案1：session设置过期时间(session.gc_maxlifetime)</h5><p>错误原因：<br>1、session设置了过期时间，超过这个时间session并不一定立刻被销毁。<br>2、session是否过期，判断的是：session那个文件的最后修改时间 + 最大生存时间 与当前时间的关系，所以如果代码中对session有写入操作，则最后修改时间会一直增大，于是session一直不会过期。<br>3、在同一服务器上有多个项目，且存储session的目录均为/tmp，session有可能提前被销毁。</p>
<p>总结：session过期时间并不能保证，session在这个时间点之前一直存在，在这个时间点之后一定销毁。<br>1,3与session的回收机制有关，具体原因后面再说。<br>另外，关于过期时间这个词，似乎会有一些乱用的情况，准确的关系是，过期时间 = session文件最后修改时间 + session最大生存时间（session.gc_maxlifetime），然后判断的就是过期时间与当前时间的关系。</p>
<h5 id="答案2：cookie设置过期时间-session-cookie-lifetime"><a href="#答案2：cookie设置过期时间-session-cookie-lifetime" class="headerlink" title="答案2：cookie设置过期时间(session.cookie_lifetime)"></a>答案2：cookie设置过期时间(session.cookie_lifetime)</h5><p>错误原因：<br>1、cookie中保存的是sessionId,到了过期时间浏览器会自动删除sessionId的cookie，但可以将把sessionId从浏览器中粘贴出来，之后用Js设置cookie，cookie中就又有了sessionId。<br>2、以上的过程，举个例子（联系上一篇文章）就是你把会员卡号记录在一张特殊的纸上，这张纸上的字到期会自动消失，那么你只需要在字消失之前把字抄在另外一张普通的纸上，如果需要就从普通的纸上把字抄回特殊的纸上，就能保证会员卡号永远在特殊的纸上存在。<br>3、关键在于，cookie中有没有sessionId,不影响服务器上对应目录下session文件是否存在。只要session文件存在，并且你能记录sessionId，就能找到session。</p>
<h5 id="答案3：使用内存数据库redis、memcache"><a href="#答案3：使用内存数据库redis、memcache" class="headerlink" title="答案3：使用内存数据库redis、memcache"></a>答案3：使用内存数据库redis、memcache</h5><p>答案正确，但并不是仅依靠php本身。<br>这类数据库有自己的过期机制，到期会自动删除对应的文件，即保证在一个时间点前一直存在，在一个时间点后一定销毁。</p>
<h5 id="答案4：在session中保存一个登录时间的时间戳，每次读session时判断是否过期"><a href="#答案4：在session中保存一个登录时间的时间戳，每次读session时判断是否过期" class="headerlink" title="答案4：在session中保存一个登录时间的时间戳，每次读session时判断是否过期"></a>答案4：在session中保存一个登录时间的时间戳，每次读session时判断是否过期</h5><p>答案正确。<br>比如下面的代码，在$auth中保存了用户id和登录时间，之后读session时都判断登录时间 + 最大生存时间 与 当前时间的关系。如果小于，那么销毁session，如果大于，就正常处理请求。<br>登录时在session中保存登录时间戳：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">($username = null, $password = null, $verify = null)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(IS_POST)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!check_verify($verify))&#123;</span><br><span class="line">              $this-&gt;error(<span class="string">'验证码错误！'</span>,<span class="string">'Index/login'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           $administrator = D(<span class="string">'Administrator'</span>);</span><br><span class="line">           $id = $administrator-&gt;login($username, $password);</span><br><span class="line">           <span class="keyword">if</span>(<span class="number">0</span> &lt; $id)&#123;</span><br><span class="line">               <span class="comment">/* 记录登录SESSION */</span></span><br><span class="line">               $auth = <span class="keyword">array</span>(</span><br><span class="line">                   <span class="string">'id'</span> =&gt; $id,</span><br><span class="line">                   <span class="string">'login_update_time'</span> =&gt; time(),</span><br><span class="line">               );</span><br><span class="line">               session(<span class="string">'administrator_auth'</span>, $auth);</span><br><span class="line">               session(<span class="string">'administrator_auth_sign'</span>,md5($auth[<span class="string">'id'</span>].$auth[<span class="string">'login_time'</span>]));</span><br><span class="line">               $this-&gt;success(<span class="string">'登录成功！'</span>, U(<span class="string">'index'</span>));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">//登录失败</span></span><br><span class="line">               <span class="keyword">switch</span>($id) &#123;</span><br><span class="line">                   <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                       $error = <span class="string">'用户不存在或被禁用！'</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> <span class="number">-2</span>:</span><br><span class="line">                       $error = <span class="string">'密码错误！'</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       $error = <span class="string">'未知错误！'</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               $this-&gt;error($error,<span class="string">'Index/login'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(is_login())&#123;</span><br><span class="line">               $this-&gt;redirect(<span class="string">'index'</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               $this-&gt;display();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>判断是否登录时，从session中取登录时间，判断登录时间 + 最大生存时间 与当前时间的关系：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 检测用户是否登录</span><br><span class="line"> * <span class="doctag">@return</span> integer 0：未登录，大于0：当前登录用户ID</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $auth  = session(<span class="string">'administrator_auth'</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($auth)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        $config = C(<span class="string">'SESSION_OPTIONS'</span>);</span><br><span class="line">        <span class="keyword">if</span>(session(<span class="string">'administrator_auth.login_time'</span>) + $config[<span class="string">'expire'</span>] &lt; time())&#123;</span><br><span class="line">            session(<span class="string">'[destroy]'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> session(<span class="string">'administrator_auth_sign'</span>) == md5($auth[<span class="string">'id'</span>].$auth[<span class="string">'login_time'</span>]) ? $auth[<span class="string">'id'</span>] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，我认为原作者所说的，在第四种答案中要设置cookie和session过期时间都为30分钟，是没有必要的，因为只要服务器上不存在对应的session文件，即使cookie中保存了sessionId也是没有意义的。</p>
<hr>
<p>通过上面的问题，我们会发现，按照常理来讲最便捷、最容易想到的第一种方法不正确的原因在于php session的回收机制并不能保证session在过期前一定存在，过期后一定销毁，那么php对于session的回收机制到底是怎样的呢？</p>
<h3 id="session执行过程关键的5个步骤如下："><a href="#session执行过程关键的5个步骤如下：" class="headerlink" title="session执行过程关键的5个步骤如下："></a>session执行过程关键的5个步骤如下：</h3><p><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160606142537.jpg" alt="image"></p>
<h5 id="1、open"><a href="#1、open" class="headerlink" title="1、open"></a>1、open</h5><p>开启对/tmp文件目录的管理</p>
<h5 id="2、read"><a href="#2、read" class="headerlink" title="2、read"></a>2、read</h5><p>从/tmp目录读session文件放到内存</p>
<h5 id="3、gc（garbage-collection）"><a href="#3、gc（garbage-collection）" class="headerlink" title="3、gc（garbage collection）"></a>3、gc（garbage collection）</h5><p>垃圾回收，将/tmp目录下过期的session文件删除，但gc并不是一定会进行垃圾回收，而是以一定的概率进行。<br>在php配置文件php.ini中，有以下两个参数：<br>session.gc_probability = 1<br>session.gc_divisor =1000<br>垃圾回收的概率是 session.gc_probability / session.gc_divisor 即 1/1000</p>
<h5 id="4、write"><a href="#4、write" class="headerlink" title="4、write"></a>4、write</h5><p>将内存中的session文件写回/tmp目录</p>
<h5 id="5、close"><a href="#5、close" class="headerlink" title="5、close"></a>5、close</h5><p>关闭对/tmp目录的管理</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>在处理请求时，如果这个请求的处理中会操作session，则有一定概率进行垃圾回收，删除过期session。考虑一种极端情况，如果没有请求，那么这个session文件会一直存在。前面所说的，第一种答案不正确的原因便在此。</p>
<h3 id="再考虑另一种极端情况，假如服务器只有一个人访问（且此时垃圾回收概率设置为1），若此时session已经过期，那么再次访问时他的session会被删除吗？"><a href="#再考虑另一种极端情况，假如服务器只有一个人访问（且此时垃圾回收概率设置为1），若此时session已经过期，那么再次访问时他的session会被删除吗？" class="headerlink" title="再考虑另一种极端情况，假如服务器只有一个人访问（且此时垃圾回收概率设置为1），若此时session已经过期，那么再次访问时他的session会被删除吗？"></a>再考虑另一种极端情况，假如服务器只有一个人访问（且此时垃圾回收概率设置为1），若此时session已经过期，那么再次访问时他的session会被删除吗？</h3><p>走一遍上面所说的过程<br>open打开文件管理，read将session读入内存<br>gc进行垃圾回收，将这个过期的session删除<br>write将内存中的session写回，close关闭文件管理</p>
<p>可以发现，那个session文件在gc过程中被删除了，但是在write过程中又写回，从表面来看那个目录下的这个文件没有变化，但实际上这个session文件是先被删除之后再被写回的。<br>这里的写回动作，应该理解为文件复制，实际测试发现session文件的创建时间和修改时间没有变化。</p>
<p>可是，没有变化，那怎么知道是先删除再创建的？还有上面的那个session过程的5个步骤又是哪来的？</p>
<p>于是就有了下篇文章<a href="http://note.youdao.com/" target="_blank" rel="external">《php session源码分析》</a>，在这篇文章中将探讨以上问题。</p>
<p>参考资料<br>1、如何设置一个严格30分钟过期的Session <a href="http://www.laruence.com/2012/01/10/2469" target="_blank" rel="external">原文链接</a><br>2、session 入库的实现2  gc() —— 垃圾回收机制 <a href="http://blog.sina.com.cn/s/blog_9d7221820102vbe6.html" target="_blank" rel="external">原文链接</a><br>3、彻底理解PHP的SESSION机制 <a href="http://www.cnblogs.com/acpp/archive/2011/06/10/2077592.html" target="_blank" rel="external">原文链接</a><br>4、php-src version 7 session.c <a href="https://github.com/SagaciousHugo/php-src/blob/master/ext/session/session.c" target="_blank" rel="external">源码</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php中的session和cookie]]></title>
      <url>http://yoursite.com/2016/05/17/php%E4%B8%AD%E7%9A%84session%E5%92%8Ccookie/</url>
      <content type="html"><![CDATA[<p>最近在项目中使用了thinkphp框架，对php中的session和cookie进行了一些研究。根据客户的需求，在文本编辑页面长时间无操作时，用户的登录状态应依然保持，即session和cookie均会自动延长其生存时间。</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a><a id="more"></a> </h2><hr>
<h1 id="session和cookie的由来"><a href="#session和cookie的由来" class="headerlink" title="session和cookie的由来"></a>session和cookie的由来</h1><h3 id="http协议的无状态性"><a href="#http协议的无状态性" class="headerlink" title="http协议的无状态性"></a>http协议的无状态性</h3><p>http是一个无状态协议，每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。<br>http协议具有的这种特性，如果不加扩展改造，就不能满足web应用的需求。通常web应用都是有状态的，前后请求是需要有关联性，比如前一次请求是用户登录，那后一次请求是查看首页。若用户登录请求成功，那么查看首页应该成功；若用户登录请求失败，那么查看首页应该失败且返回登录页。<br>因此，为了使http协议也能够有状态，引入了session和cookie机制。<br>可做此理解，web应用的有状态性 = http的无状态性 + session、cookie状态机制</p>
<h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p>将上面的问题转化为一个生活中超市购物的例子。<br>比如沃尔玛，每天有数以千计的人去进行购物，而你今天去购物，又或者明天去购物，这两次购物行为之间没有什么关系，可以认为是独立的，而且对于超市而言，并不知道这次是谁在购物，这样的一次购物行为就相当于一次http请求。而如果考虑用户购物积分机制，每次购物都会根据金额为该用户增加积分，这样为了证明是你在购物，所以超市会给你发一个凭证——会员卡。<br>于是在每次购物时，出示会员卡，就把这次购物变成了超市知道是某个会员在购物的购物行为。</p>
<p>对于这张会员卡应该有两层理解的含义：1、对于超市，数据库里有一张表，存着这个卡号以及用户的积分信息 2、对于用户，手里有一张卡，卡内有芯片记录着卡号 </p>
<p>把上述例子中超市变成服务器，购物的人变成客户端（这里的客户端即，浏览器），购物行为变成访问请求，就回到了web应用场景。<br>那么，用户手里的那张会员卡和超市数据库中存储卡号和用户积分的那条记录在web应用中又是什么呢？<br>答案就是：<br>session的作用就相当于上面所说超市数据库中存储卡号及用户信息的那条记录,sessionid即卡号。<br>cookie的作用就相当于用户手中记录卡号的会员卡。</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>在php中，默认的session机制，是用磁盘文件实现，每一个session都是服务器tmp目录下的一个文件，<br>如图所示：<img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160601105934.jpg" alt="image"><br>在这个文件中通常保存一些用户相关的信息,在本项目中保存了用户id和登录时间，以及这两个参数进行md5加密以后的值，用于之后判断访问请求是否为登录状态。</p>
<pre><code>$auth = array(
    &apos;id&apos; =&gt; $id,
    &apos;login_time&apos; =&gt; time(),
);
session(&apos;administrator_auth&apos;, $auth);
session(&apos;administrator_auth_sign&apos;,md5($auth[&apos;id&apos;].$auth[&apos;login_time&apos;]));
</code></pre><p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这次请求里是否已包含了一个session标识，即sessionid,如果已包含一个sessionid，则从服务器上找到对应的session使用，否则就创建一个session并把sessionid返回给浏览器。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是储存在用户本地终端（浏览器）上的数据，服务器可以利用cookie包含的信息以判断在http传输中的状态。<br>服务器创建session后，会将sessionid返回给浏览器，浏览器会将sessionid存在cookie中，当再次请求时，浏览器会在请求中带上cookie中所保存的全部参数。<br>例如下面的过程：<br>第一次请求进入登录页面，cookie中没有sessionid，返回报文给cookie设置sessionid为s1vu7me3dt718g2fjlmuclk2i4<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160601112535.png" alt="image"><br>此时服务器tmp目录下增加了文件名为sess_s1vu7me3dt718g2fjlmuclk2i4的文件，说明服务器为第一请求创建了对应的session<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160601112734.png" alt="image"><br>第二次请求用户登录，可以看到请求报文中cookie中有sessionid=s1vu7me3dt718g2fjlmuclk2i4<img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160601112847.png" alt="image"></p>
<h1 id="如何保持用户登录状态"><a href="#如何保持用户登录状态" class="headerlink" title="如何保持用户登录状态"></a>如何保持用户登录状态</h1><p>通过上面的说明，可以知道保持用户登录状态，即一次有状态的访问需要从cookie中得到sessionid，并且服务器tmp目录下有对应的session文件。即保持用户状态需要两个条件：1、cookie有效 2、session有效<br>这就引出了两个问题，cookie的生命周期和session的生命周期。</p>
<h3 id="cookie的生命周期"><a href="#cookie的生命周期" class="headerlink" title="cookie的生命周期"></a>cookie的生命周期</h3><p>cookie一般不是永久保存在浏览器，当到了过期时间时，cookie会被删除，过期时间一般有以下2种情况<br>1、浏览会话结束时<br>如果不进行设置，cookie默认浏览窗口关闭即失效</p>
<p>2、服务器返回报文set-cookie时，会设置cookie对应的过期时间，则cookie在该过期时间之前均有效</p>
<h3 id="session的生命周期"><a href="#session的生命周期" class="headerlink" title="session的生命周期"></a>session的生命周期</h3><p>服务器创建session时，会有session对应的失效时间，超过这个时间，服务器会删除tmp目录下对应的session文件。<br>//TODO session回收机制</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>那么对于开头需求，在文本编辑页面长时间无操作时，用户的登录状态应依然保持，就需要在这个页面可以保持cookie和session均有效。  </p>
<h3 id="1、在对应页面script中使用setInterval方法每隔5分钟向后台发一次请求"><a href="#1、在对应页面script中使用setInterval方法每隔5分钟向后台发一次请求" class="headerlink" title="1、在对应页面script中使用setInterval方法每隔5分钟向后台发一次请求"></a>1、在对应页面script中使用setInterval方法每隔5分钟向后台发一次请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> setInterval(function ()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;&#123;:U(&apos;sessionDelay&apos;)&#125;&quot;,</span><br><span class="line">        type: &quot;GET&quot;,</span><br><span class="line">        async: true,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        dataType: &quot;json&quot;,</span><br><span class="line">        success: function(data)&#123;</span><br><span class="line">            if(data.status==&apos;success&apos;)&#123;</span><br><span class="line">                console.log(&quot;the user is editing.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,5*60*1000);</span><br></pre></td></tr></table></figure>
<h3 id="2、每次访问请求都更新cookie的过期时间"><a href="#2、每次访问请求都更新cookie的过期时间" class="headerlink" title="2、每次访问请求都更新cookie的过期时间"></a>2、每次访问请求都更新cookie的过期时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function __construct() &#123;</span><br><span class="line">        parent::__construct();</span><br><span class="line">        define(&apos;ID&apos;, is_login());</span><br><span class="line">        if (!ID) &#123;// 还没登录 跳转到登录页面</span><br><span class="line">            $this-&gt;redirect(&apos;Index/login&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        cookie(&apos;PHPSESSID&apos;, cookie(&apos;PHPSESSID&apos;), array(&apos;expire&apos;=&gt;24 * 3600, &apos;path&apos;=&gt;&quot;/&quot;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、后台在判断是否登录时，根据需要延长session有效时间"><a href="#3、后台在判断是否登录时，根据需要延长session有效时间" class="headerlink" title="3、后台在判断是否登录时，根据需要延长session有效时间"></a>3、后台在判断是否登录时，根据需要延长session有效时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 检测用户是否登录</span><br><span class="line"> * @return integer 0：未登录，大于0：当前登录用户ID</span><br><span class="line"> */</span><br><span class="line">function is_login()&#123;</span><br><span class="line">    $auth  = session(&apos;administrator_auth&apos;);</span><br><span class="line">    if (empty($auth)) &#123;</span><br><span class="line">        session(&apos;login_update_time&apos;,time());</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        $config = C(&apos;SESSION_OPTIONS&apos;);</span><br><span class="line">        if(time() - session(&apos;login_update_time&apos;) &gt; $config[&apos;expire&apos;] / 2 )&#123;</span><br><span class="line">            session(&apos;login_update_time&apos;,time());</span><br><span class="line">        &#125;</span><br><span class="line">        return session(&apos;administrator_auth_sign&apos;) == md5($auth[&apos;id&apos;].$auth[&apos;login_time&apos;]) ? $auth[&apos;id&apos;] : 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上三点，实现了在编辑页面无限长时间无操作，仍然保持用户登录状态。</p>
<p>另，thinkphp框架中并没有对cookie进行有效时间设置，所以如果在代码中不显式的设置，那么cookie过期时间均为浏览会话结束时，这样的话即使session依然存在，本地却没有保存sessionid，就无法达到保持登录状态的需求。<br>在研究这个问题时，看到了一篇文章，如下<br><img src="http://o7bsrhxey.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160601133111.jpg" alt="image"><br>这位博主错误理解了session和cookie，因为没有显式设置cookie过期时间导致无法保持登录状态，却理解为session失效，以及thinkphp框架有bug，并改了框架源码= =。<br><a href="http://baijunyao.com/article/50" target="_blank" rel="external">原文链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/05/16/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
